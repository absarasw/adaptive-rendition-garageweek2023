{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,C,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,C,E,iB,C,E,Q,C,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,E,a,C,C,G,E,E,O,C,iB,I,G,E,E,O,C,U,I,G,E,E,O,C,oB,I,G,I,E,E,S,E,E,S,E,E,QCMO,OAAM,UAAuB,MACnC,KAAO,gBAAiB,AAExB,cAAc,CACb,KAAK,CAAC,qBACP,CACD,CAEe,eAAA,EAAyB,CAAW,CAAE,CAAO,EAC3D,GAAI,CAAC,EACJ,MAAM,AAAI,MAAM,qBAGjB,EAAU,CACT,UAAW,OAAO,iBAAlB,CACA,GAAG,CAAO,AACX,EAEA,GAAM,CAAA,UAAC,CAAS,CAAC,CAAG,EAChB,CAAA,SAAC,EAAW,MAAA,CAAO,CAAG,EACpB,EAAW,AAAa,WAAb,EAEb,GACH,CAAA,EAAW,IADZ,EAIA,IAAM,EAAS,IAAI,EAAA,WAAgB,CAAE,CAAC,cA5Bd,UA4B6C,GAEjE,GACH,EAAO,WAAA,CAAY,GAGpB,MAAM,AAAA,CAAA,EAAA,EAAA,QAAa,AAAb,EAAe,EAAa,GAElC,IAAI,EAAS,EACP,EAAS,EAAE,CAEX,EAAmB,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,MAAA,CAAO,EAAQ,GAAU,EAAO,IAAA,CAAK,IAEtF,UAAW,IAAM,KAAS,EAIzB,GAHA,EAAO,IAAA,CAAK,GAGR,AAFJ,CAAA,GAAU,EAAM,MAAhB,AAAA,EAEa,EAAW,CACvB,IAAM,EAAQ,IAAI,CAMlB,OAJI,GAAU,AAAA,EAAA,SAAc,CAAE,UAAA,EAC7B,CAAA,EAAM,YAAA,CAAe,GADtB,EAIM,CACP,CAGD,OAAO,GACR,CAEO,eAAe,EAAkB,CAAM,CAAE,CAAO,EACtD,OAAO,EAAU,EAAQ,CAAC,GAAG,CAAO,CAAE,SAAU,QAAQ,EACzD,C","sources":["<anon>","node_modules/get-stream/index.js"],"sourcesContent":["function $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar parcelRequire = $parcel$global[\"parcelRequire6705\"];\nparcelRequire.register(\"9bBmB\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"MaxBufferError\", () => $6b021fbe4c1d3a8a$export$8b174020ca647416);\n$parcel$export(module.exports, \"default\", () => $6b021fbe4c1d3a8a$export$2e2bcd8739ae039);\n$parcel$export(module.exports, \"getStreamAsBuffer\", () => $6b021fbe4c1d3a8a$export$7043a390e4973a6);\n\nvar $6ZWSX = parcelRequire(\"6ZWSX\");\n\nvar $ioRHp = parcelRequire(\"ioRHp\");\n\nvar $kjyEk = parcelRequire(\"kjyEk\");\nconst $6b021fbe4c1d3a8a$var$maxHighWaterMark = 2147483647;\nclass $6b021fbe4c1d3a8a$export$8b174020ca647416 extends Error {\n    name = \"MaxBufferError\";\n    constructor(){\n        super(\"maxBuffer exceeded\");\n    }\n}\nasync function $6b021fbe4c1d3a8a$export$2e2bcd8739ae039(inputStream, options) {\n    if (!inputStream) throw new Error(\"Expected a stream\");\n    options = {\n        maxBuffer: Number.POSITIVE_INFINITY,\n        ...options\n    };\n    const { maxBuffer: maxBuffer } = options;\n    let { encoding: encoding = \"utf8\" } = options;\n    const isBuffer = encoding === \"buffer\";\n    if (isBuffer) encoding = null;\n    const stream = new (0, $ioRHp.PassThrough)({\n        highWaterMark: $6b021fbe4c1d3a8a$var$maxHighWaterMark\n    });\n    if (encoding) stream.setEncoding(encoding);\n    await (0, $kjyEk.pipeline)(inputStream, stream);\n    let length = 0;\n    const chunks = [];\n    const getBufferedValue = ()=>isBuffer ? (0, $6ZWSX.Buffer).concat(chunks, length) : chunks.join(\"\");\n    for await (const chunk of stream){\n        chunks.push(chunk);\n        length += chunk.length;\n        if (length > maxBuffer) {\n            const error = new $6b021fbe4c1d3a8a$export$8b174020ca647416();\n            if (length <= (0, $6ZWSX.constants).MAX_LENGTH) error.bufferedData = getBufferedValue();\n            throw error;\n        }\n    }\n    return getBufferedValue();\n}\nasync function $6b021fbe4c1d3a8a$export$7043a390e4973a6(stream, options) {\n    return $6b021fbe4c1d3a8a$export$2e2bcd8739ae039(stream, {\n        ...options,\n        encoding: \"buffer\"\n    });\n}\n\n});\n\n\n//# sourceMappingURL=get-stream.acb19968.js.map\n","import {Buffer, constants as BufferConstants} from 'node:buffer';\nimport {PassThrough as PassThroughStream} from 'node:stream';\nimport {pipeline as streamPipeline} from 'node:stream/promises';\n\nconst maxHighWaterMark = 2_147_483_647;\n\nexport class MaxBufferError extends Error {\n\tname = 'MaxBufferError';\n\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t}\n}\n\nexport default async function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Number.POSITIVE_INFINITY,\n\t\t...options,\n\t};\n\n\tconst {maxBuffer} = options;\n\tlet {encoding = 'utf8'} = options;\n\tconst isBuffer = encoding === 'buffer';\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({highWaterMark: maxHighWaterMark});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tawait streamPipeline(inputStream, stream);\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tconst getBufferedValue = () => isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\n\tfor await (const chunk of stream) {\n\t\tchunks.push(chunk);\n\t\tlength += chunk.length;\n\n\t\tif (length > maxBuffer) {\n\t\t\tconst error = new MaxBufferError();\n\n\t\t\tif (length <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = getBufferedValue();\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn getBufferedValue();\n}\n\nexport async function getStreamAsBuffer(stream, options) {\n\treturn getStream(stream, {...options, encoding: 'buffer'});\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","register","module","exports","value","$6b021fbe4c1d3a8a$export$8b174020ca647416","$6b021fbe4c1d3a8a$export$2e2bcd8739ae039","$6b021fbe4c1d3a8a$export$7043a390e4973a6","$6ZWSX","$ioRHp","$kjyEk","Error","name","constructor","inputStream","options","maxBuffer","Number","POSITIVE_INFINITY","encoding","isBuffer","stream","PassThrough","highWaterMark","setEncoding","pipeline","length","chunks","getBufferedValue","Buffer","concat","join","chunk","push","error","constants","MAX_LENGTH","bufferedData"],"version":3,"file":"get-stream.acb19968.js.map"}